# 前言

## Go语言起源

编程语言的演化跟生物物种的演化类似，一个成功的编程语言的后代一般都分继承它们的祖先的优点；当然有时多种语言杂合也可能产生令人惊讶的特性；还有一些激进的新特性可能并没有先例。通过观察这些影响，我们可以学到为什么一门语言是这样的，它已经适应了怎样的环境。



Go语言有时候被描述为"C类似语言"，或"21世纪的C语言"。Go从C语言继承了相似的表达式语法、控制流程结构、基础数据类型、调用参数值、指针等很多思想，还有C语言一直所看中的编译后机器码的运行效率以及和现有操作系统的无缝适配。



但在Go语言的家庭树中还有其它的祖先。其中一个有影响力的分支来自Niklaus Wirth所设计的Pascal语言。然后Modula-2语言激发了包的概念。然后Oberon语言摒弃了模块接口文件和模块实现文件之间的区别。第二代的Oberon-2语言直接影响了包的导入和声明的语法，还有Oberon语言的面向对应特性所提供的方法的声明语法等。

// TODO LIST

## Go语言项目

所有的编程语言都反映了语言设计都对编程哲学的反思，通常包括之前的语言所暴露的一些不足地方的改进。Go项目是在Google公司维护超级复杂的几个软件系统遇到的一些问题的反思。

下发kRob Pike所说，"软件的复杂性是乘法级相关的"，通过增加一部分的复杂性来修复问题通常将慢慢地增加其他部分的复杂性。通过增加功能、选项和配置是修复问题的最快途径，但是这很容易让人忘记简洁的内涵，即从长远来看，简洁依然是好软的关键因素。



## 本书的组织 

我们假设你已经有一种或多种其他编程语言的使用经历，不管是类似C、C++或Java的编译型语言，还是类似Python、Ruby、JavaScript等脚本语言，因此我们不会像对完全的编程语言初学者那样解释所有的细节。因为，Go语言的变量、常量、表达式、控制流程和函数等基础语法也是类似的。



第一章包含了本教程的基本结构，通过十风个程序介绍了用Go语言如何实现类似读写文件、文本格式化、创建图像、网络客户端和服务器通讯等日常工作。



第二章描述了Go语言程序的基本元素结构、变量、新类型定义、包和文件、以及作用域等概念。



第三章讨论了数字、布尔值、字符串和常量，并演示了如何显示和处理Unicode字符。



第四章描述了复合类型，从简单的数组、字典、切片到动态列表。



第五章、涵盖了函数、并讨论了错误处理、panic和recover，还有defer语句。



第一章到第五间是基础部分，主流命令式编程语言这部分类似。个别之处，Go语言有自己特色的语法和风格，但是大多数程序员能很快适应。其余章节是Go语言特有的： 方法、接口、并发、包、测试和反射等语言特性。



Go语言的面向对象机制与一般语言不同。它没有类层次结构，甚至可以说没有类；仅仅通过组合(而不是继承)简单的对象来构建复杂的对象。方法不仅可以定义在结构体上，而且，可以定义在任何用户定义的类型上；并且，具体类型和抽象类型(接口)之间的关系是隐式的，所以很多类型的设计者可能并不知道该类型到底实现了哪些接口。方法在第六章讨论，接口在第七章讨论。



第八章讨论了基于顺序通信进程(CSP)概念的并发编程，使用goruntines和channels处理并发编程。



第九章则讨论了传统的基于共享变量的并发编程



第十章描述了包机制和包的组织结构。这一章还展示了如何有效地利用Go自带的工具，使用单个命令完成编译、测试、基准测试、代码格式化、文档以及其他诸多任务



第十一章讨论了单元测试，Go语言的工具和标准库中集成了经量级的测试功能，避免了强大但复杂的测试框架。测试库提供了一些基本构件，必要时用来构建复杂的测试构件。



第十二章讨论了反射，一种程序在运行期间审视自己的能力。反射是一个强大的编程工具，不过要谨慎地合适的使用；这一章利用反射机制实现一些重要的Go语言库函数，展示了的强大用法。



第十三章解释了底层编程的细节，在必要时，可以合租unsafe包绕过Go语言安全的类型系统。



# 入门

## Hello,World

`ch1/helloworld.go`

```golang
package main

import "fmt"

func main(){
	fmt.Println("Hello,世界")
}
```

Go是一门编译型语言，Go语言的工具链将源代码及其依赖转换成计算机的机器指令。Go语言提供的工具都通过一个单独的命令`go`调用，`go`命令有一系列子命令。最简单的一个子命令就是run。这个命令编译一个或多个以`.go`结尾的源文件，链接库文件，并运行最终生成的可执行文件。

```bash
go run helloworld.go
```

这个命令会输出:

```bash
Hello，世界
```

Go语言原生支持Unicode，它可以处理全世界的任何语言的文本。

如果不只是一次性实验，希望保存编译结果以备将来之前，可以用build子命令:

```bash
go build helloworld.go
```

这个命令生成一个名为`helloworld`的可执行的二进制文件，之后可以随时运行它，不需要任何处理。

```bash
./helloworld
Hello，世界
```

Go语言的代码通过**包**(package)组织，包类似其它语言里的库(libraries)或者模块(modules)。一个包由位于单个目录下的一个或多个`.go`源代码文件组成，目录定义包的作用。每个源文件都以一条`package`声明语句开始，这个例子里就是`package main`，表示该文件属于哪个包，紧跟着一系列导入(import)的包，之后是存储在这个文件里的程序诗句。

Go的标准库提供了100多个包，以支持常见的功能，如输入、输出、排序以及文本处理。比如`fmt`包，就含有格式化输出、接收输入的函数。`Pringln`是其中一个基础函数，可以打印以空格间隔的一个或多个值，并在最后添加一个换行符，从而输出一整行。

`main`包比较特殊，它定义了一个独立可执行的程序，而不是一个库。在`main`里的`main`函数也很特殊，它是整个程序执行时的入口。`main`函数所做的事情就是程序做的。当然了，`main`函数一般调用其它包里的函数完成很多工作，比如`fmt.Pringln`。

必须告诉编译器源文件需要哪些包，用`package`声明后面的`import`来导入这些包。`hello world`程序仅使用了一个来自于其他包的函数，而大多数程序可能导入更多的包。

必须恰当导入需要的包，缺少了必要的包或导入不需要的包，程序都无法编译通过。这项严格要求避免了程序开发过程中引入 未使用的包。

`import`声明必要跟在文件的`package`声明之后，随后，则是组成程序的函数、变量、常量、类型声明语句(由关键字`func`,`var`,`const`,`type定义`)。这些内容的声明顺序并不重要。

一人函数的声明由`func`关键字、函数名、参数列表、返回值列表(这个例子里的`main`函数参数列表和返回值列表都是空的)，以及包含在大括号里的函数体组成。

Go语言不需在语句或声明的末尾添加分号，除非一行上有多条语句。实际上，编译器会主动地把特定符号后的换行符转换为分号，因此换行符添加的位置会影响Go代码的正确解析（比如行末是标识符、整数、浮点数、虚数、字符或字符串文字、关键字`break`,`continue`,`fallthrugh`,`return`中的一个、运算符和分隔符`++`,`--`,`)`,`]`或`}`中的一个）。比如，函数在左操作`{`必须和`func`函数声明在同一行上，且位于末尾，不能独间点一行，而表达式`x+y`中可在`+`后换行，不能在`+`前换行。

Go语言在代码格式上采取了很强硬的态度。`gofmt`工具把代码格式化为标准格式，`go`工具中的`fmt`子命令使用`gofmt`工具格式化指定包里的所有文件或当前上当 中的文件(默认情况下)。

许多文本编辑器可以配置为每次在保存时自动运行`gofmt`，因此源文件总可以保持正确的形式。此外，一个相关的工具`goimports`可以按需管理导入声明的插入和移除。它不是标准发布版的一部分，可以通过执行下面的命令获取到：

```bash
go get golang.org/x/tools/cmd/goimports
```

对大多数用户来说,按照常规方式下载,编译包,执行自带的测试,查看文档等操作,使用`go`工具都可以实现.

## 命令行参数

大部分程序处理输入然后产生输出,这就是关于计算的大致定义. 但程序怎样获取数据的输入呢? 一些程序自己生成数据,更多的时候,输入来自一个外部源: 文件,网络连接,其他程序的输出,键盘,命令行参数等 . 随后的一些示例将从命令行参数开始讨论这些输入.

`os`包提供一些函数和变量,以与平台无关的方式和操作系统打交道.命令行参数以`os`包中的`Args`名字的变量供程序访问,在`os`包外面,使用`os.Args`这个名字 .

变量`os.Args`是一个字符串slice. slice是Go中的基础概念,很快我们将讨论到排除, 现在只需要理解它是一个动态容量的顺序数据s,可通过`s[i]`来访问单个元素,通过`s[m:n]`来访问一段连续子区间,数据长度用`len(s)`表示,与大部分语言一样,在Go中,所有的索引使用半开区间,即包含每一个索引,不包含最一个索引,因为这样的逻辑比较简单,如`s[m:n]`,其中,0<=m<=n<=`len(s)`,包含n-m个元素.

`os.Args`的第一个元素是`os.Args[0]`,它是命令本身的名字,另外的元素是程序开始执行时的参数.表达式`s[m:n]`表示一个从第m个到第n-1个元素的slice,所以下一个示例中slice需要的元素是`os.Args[1:len(os.Args)]`. 如果m或n缺失,默认分别是0或`len(s)`,所以我们可以将期望的slice简写为`os.Args[1:]`

这里有一个UNIX echo命令的实现,它将命令参数输出到一行,该实现导入两个包,使用圆括号括起来的列表,而不是独立的`import`声明.两者都合法的,但为了方便 ,我们使用了列表的方式.导入的顺序是没有关系的, `gofmt`工具将其按照字母顺序表进行排序.

`ch1/echo1`

```golang
// echo1输出其命令行参数
package main

import (
	"fmt"
	"os"
)
func main(){
	vars,sep string
	for i:=1;i<len(os.Args);i++{
		s += sep + os.Args[i]
		sep = " "
	}
	fmt.Println(s)
}
```

注释以//开头,所有以//开开头的文本给程序员看的注释,编译器将会忽略它们.

`var`关键字声明了两个`string`类型的变量`s`和`sep`.变量可以在声明的时候初始化.如果变量没有明确地初始化,它将隐式地初始化为这个类型的空值(也被称为零值).如,对于数字初始化结果为0,对于字符串是空字符串`""`.

对于数字,Go提供常规的算术和逻辑操作符,当应用于字符串时,`+`操作符对字符串的值进行追加操作.

for循环的三个组成部分两边不用小括号,大括号是必需的,但左大括号必需和for在同一行.

如上所述,每次循环,字符串`s`有了新的内容,`+=`语句通过追加旧的字符串,空格字符和下一个参数,生成一个新的字符串,然后把新的字符串赋给`s`,旧的内容不需要使用,会被强行垃圾回收.

如果有大量的数据需要处理,这样的代价会比较大.一个简单和高效的方式是使用`strings`包的`Join`函数

`ch1/ceho3`

```golang
func main(){
	fmt.Println(strings.Join(os.Args[1:]," "))
}
```

最后,如果不关心格式,只想看值,或只是调试,可以用`Println`格式化结果

```golang
fmt.Println(os.Args[1:])
```



## 查找重复的行

用于文件复制、打印、检索、排序、统计的程序，通常有一个相似的结构: 在输入接口上循环读取，然后对每一个元素进行一些计算，在运行时或在最后输出结果。将展示本个版本的dup程序，它受UNIX的`uniq`命令启发来找到相邻的重复行。

第一个版本的dup程序输出标准输入中出现次数大于1的行，前面是次数。

`ch1/dup1`

```golang
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main(){
	counts := make(mat[string]int)
	input := bufio.NewScanner(os.Stdin)
	for input.Scan() {
		counts[input.Text()]++
	}
	// 注意: 忽略input.Err()中可能的错误
	for line,n := range counts {
		if n > 1 {
			fmt.Printf("%d\t%s\n",n,line)
		}
	}
}
```

正如`for`循环一样,`if`语句条件两边也不加括号，但是主体部分需要加。`if`语句的`else`部分是可选的，在`if`的条件为`false`时执行。

`map`存储了键/值(key/value)的集合，对集合元素，提供常数时间的存、取或测试操作。键可以是任意类型，只要其值能用`==`运算符比较，最常见的是字符串;值可以是任意类型。这个例子中的键是字符串，值中整数。内置函数`make`创建空`map`，此外，它还有别的作用。

每次`dup`读取一行输入，该行被当做`map`，其对应的值递增。`counts[input.Text()]++`语句等价下面两句

```golang
line := input.Text()
counts[line] = count[line] + 1
```

`map`中不含某个键时不用担心，首次读取到新行时，等号右边的表达式`counts[line]`的值将被计算为其类型的零值，对于`int`即0

为了打印结果，我们使用了基于`range`的循环，并在`counts`这个`map`上迭代。每次迭代得到两个结果，键和其在`map`中对应的值。`map`的迭代顺序并不确定，从实践中来看，该顺序随机，每次运行都会变化。这种设计是有意为之的，因为能防止程序依赖特定遍历顺序，而这是无法保证的。

继续来看`bufio`包，它使处理输入和输出方便又高效。`Scanner`类型是该最有用的特性之一，它读取输入，以行或单词为单位断开，这是处理以行为单位的输入内容的最简单方式。

程序使用短变量的声明方式，新建一个`bufio.Scanner`类型的`input`变量:

```go
input := bufio.Scanner(os.Stdin)
```

扫描器从程序的标准输入进行读取，每一次调用`input.Scan()`读取下一行，并且将结尾的换行符去掉通过调用`input.Text()`来获取读到的内容。`Scan`函数在读到新行时，返回`true`，在没有更多的内容时返回`false`。

程序dup1中的格式的字符串还包含一个制表符`\t`和一个换行符`\n`。字符串字面量可以包含类似转义序列(escape sequenc)来表示不可见字符。`Printf`默认不写换行符。执照约定，诸如`log.Printf`和`fmt.Printf`之类的格式化函数以`f`结尾，使用和`fmt.Printf`相同的格式化规则：而那些以`ln`结尾的函数(如`Println`)则使用`%v`的方式来格式化参数，并在最后追加换行符。

许多程序既可以像dup一样从标准输入进行读取，也可以从具体的文件读取。下一个版本的dup程序可以从标准输入或一个文件列表进行读取，使用`os.Open`函数来逐个打开:

`ch1/dup2`

```golang
// dup2 打印输入中多次出现的行的个数和文本
// 它从 `stdin`或指定的文件列表读取
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main(){
	counts := make(map[string]int)
	files := os.Args[1:]
	if len(files) == 0 {
		countLines(os.Stdin,counts)
	}else {
		for _,arg := range files {
			f,err := os.Open(arg)
			if err != nil {
				fmt.Fprintf(os.Stderr,"dup2: %v\n",err)
				continue
			}
			countLines(f,counts)
			f.Close()
		}
	}
	for line,n := range counts {
		if n > 1 {
			fmt.Printf("%d\t%s\n",n,line)
		}
	}
}

func countLines(f *os.File,counts map[string]int){
	input := bufio.NewScanner(f)
	for input.Scan() {
		counts[input.Text()]++
	}
	// 注意: 忽略`input.Err()`中可能的错误
}
```



## GIF动画



## 获取URL



## 并发获取多个URL



## Web服务



## 本章要点



#  程序结构

## 命名



## 声明



## 变量



## 赋值



## 类型



## 包和文件





## 作用域



# 基础数据类型







